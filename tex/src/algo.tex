\documentclass{article}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}%% http://ctan.org/pkg/xcolor
\usepackage[utf8]{inputenc}
\usepackage{xspace}
\usepackage{array}
%\usepackage{amsthm}
\usepackage{amsmath} 
\usepackage{amssymb} 
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{url}
\usepackage{tikz}
\usepackage{fp}
\usepackage{subfig}
\usetikzlibrary{arrows,shadows,fit,calc,positioning,decorations.pathreplacing,matrix,shapes,petri,topaths,fadings,mindmap,backgrounds,shapes.geometric}
\usepackage{geometry}
\usepackage{xifthen}
\usepackage{rotating}


\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}


\newcommand{\tru}[0]{\texttt{true}}
\newcommand{\fal}[0]{\texttt{false}}
% \newcommand{\tru}[0]{1}
% \newcommand{\fal}[0]{0}


\newcommand{\setex}[1]{\ensuremath{{\mathcal X}^{#1}}\xspace}
\newcommand{\posex}{{\setex{\top}}\xspace}
\newcommand{\negex}{{\setex{\bot}}\xspace}
\newcommand{\setcube}[1]{\ensuremath{{\mathcal C}^{#1}}\xspace}
\newcommand{\poscube}{{\setcube{1}}\xspace}
\newcommand{\negcube}{{\setcube{0}}\xspace}
\newcommand{\features}{\ensuremath{{\mathcal F}}\xspace}
\newcommand{\feat}{\ensuremath{f}}
\newcommand{\classifier}{\ensuremath{f}}
\newcommand{\lit}[1]{\ensuremath{l_{#1}}}
\newcommand{\var}{\ensuremath{x}}
\newcommand{\truelit}[1]{\ensuremath{\var_{#1}}}
\newcommand{\falselit}[1]{\ensuremath{\bar{\var_{#1}}}}
\newcommand{\ex}{\ensuremath{\var}}
\newcommand{\cube}{\ensuremath{c}}
\newcommand{\universe}{\ensuremath{{\mathcal U}}}
\newcommand{\entropy}[1]{\ensuremath{{H}({#1})}\xspace}
\newcommand{\probability}[1]{\ensuremath{{Pr}({#1})}\xspace}


\newcommand{\nodes}[0]{\ensuremath{{\cal N}}}
\newcommand{\blossom}[0]{\ensuremath{{\cal B}}}
\newcommand{\sequence}[0]{\ensuremath{{\cal S}}}

\newcommand{\anode}[0]{\ensuremath{i}}
\newcommand{\bnode}[0]{\ensuremath{b}}
\newcommand{\afeat}[0]{\ensuremath{f}}
\newcommand{\ub}[0]{\ensuremath{ub}}
\newcommand{\error}[0]{\ensuremath{error}}
\newcommand{\depth}[1][]{\ensuremath{\ifthenelse{\equal{#1}{}}{depth}{depth({#1})}}}
\newcommand{\test}[1][]{\ensuremath{\ifthenelse{\equal{#1}{}}{test}{test({#1})}}}
\newcommand{\dom}[1][]{\ensuremath{\ifthenelse{\equal{#1}{}}{dom}{dom({#1})}}}
\newcommand{\best}[1][]{\ensuremath{\ifthenelse{\equal{#1}{}}{{best}}{{best({#1})}}}}
\newcommand{\opt}[1][]{\ensuremath{\ifthenelse{\equal{#1}{}}{opt}{opt({#1})}}}
\newcommand{\child}[1][]{\ensuremath{\ifthenelse{\equal{#1}{}}{{child}}{{child({{#1}})}}}}


	\SetKwFunction{storebest}{storeBest}
	\SetKwFunction{solution}{solution}
	\SetKwFunction{deadend}{deadEnd}
	\SetKwFunction{expend}{expend}
	\SetKwFunction{backtrack}{backtrack}
	\SetKwFunction{dt}{BTDT}
	\SetKwFunction{pop}{pop}
	\SetKwFunction{push}{push}
	\SetKwFunction{prune}{prune}
	\SetKwFunction{grow}{grow}
	\SetKwFunction{branch}{branch}
	\SetKwFunction{select}{select\&remove}
	
	

\DontPrintSemicolon

\title{Backtracking DT}

% \author{Emmanuel Hebrard\inst{1} \and George Katsirelos\inst{2}}
% \institute{LAAS-CNRS, Universit\'e de Toulouse, CNRS, France, email: hebrard@laas.fr
  % \and MIAT, UR-875, INRA, France, email: gkatsi@gmail.com \footnote{The second author was partially supported by the french ``Agence nationale de
% la Recherche'', project DEMOGRAPH, reference ANR-16-C40-0028.}}

\begin{document}
	% \newgeometry{bottom=3cm,top=3cm}

\maketitle

\section*{Introduction}

We consider the problem of finding the bounded-depth decision tree of maximum accuracy.
The state of the art includes MIP approaches (BinOCT), a MaxSAT approach based on the SAT encoding proposed by Narodytska et al, and DL8.5.
The latter algorithm is by far the most efficient, however, it is not \emph{anytime}: the left branch must be optimally solved before a solution of the right branch can be found. Moreover the use of a cache structure means that it uses a lot of memory. This algorithm is practical for a maximum depth of 4 (although using gigabytes of memory) but often not much beyond. Therefore, in a number of cases, a greedy heuristic (such as CART) is still the best method in practice.

\medskip

In this note we introduce what is essentially an anytime version of DL8.5, without cache.
This algorithm therefore uses linear (in the size of the tree) memory and anytime, hence in principle strictly better than CART. Moreover, on instance where DL8.5 can find a solution, the algorithm described in this note is significantly faster (by about a factor 10).

\section*{Algorithm}

For readability, we cut the algorithm into four blocks. The initialisation procedure (Algorithm~\ref{alg:init}) set up the data structures used in all other procedures:
\begin{itemize}
	\item \sequence\ is simply the list of nodes in the current tree, ordered as they are explored.
	\item \nodes\ is the set of integers used to index a node of the current tree
	\item \blossom\ is the set of nodes which do no have an assigned test yet
	\item \depth\ stores the depth of a node
	\item \test\ stores the feature tested at a node
	\item \dom\ stores the set of possible features which have no yet been tried for this node 
	\item \best\ stores the error of the best subtree rooted at a node 
	\item \opt\ indicates whether the best subtree of a given node is optimal
	\item \child\ stores the children of a node (children can be nodes or $\{\top, \bot\}$)
\end{itemize}

Algorithm~\ref{alg:search} is a bactracking procedure which expends a current decision tree
	
	\begin{algorithm}
		\caption{Data Structures\label{alg:init}}
		\TitleOfAlgo{Initialise}
		$\sequence \gets []$\;
		$\blossom \gets \emptyset$\;
		$\nodes \gets \emptyset$\;
		$\ub \gets \min(|\negex|,|\posex|)$\;
		$\error \gets ub$\;
		
		$\child \gets (\lambda : \mathbb{N} \times \{\fal, \tru\} \mapsto \emptyset)$\;
		$\depth \gets (\lambda : \mathbb{N} \mapsto 0)$\;
		
		$\test \gets (\lambda : \mathbb{N} \mapsto \emptyset)$\;
		$\dom \gets (\lambda : \mathbb{N} \mapsto \features)$\;
		
		$\best \gets (\lambda : \mathbb{N} \mapsto \infty)$\;
		$\opt \gets (\lambda : \mathbb{N} \mapsto \fal)$\;
	\end{algorithm}
	
	
	
	\begin{algorithm}
		\caption{Create a new node after branching\label{alg:alloc}}
		\TitleOfAlgo{\grow} 
	  \KwData{integer \anode}

		$\nodes \gets \nodes \cup \{\anode\}$\;
		$\dom[\anode] \gets \features$ sorted by decreasing conditional error $\min(|\posex(\anode=\afeat)|,|\negex(\anode=\afeat)|)$\;
		$\test[\anode] \gets \pop(\dom[\anode])$\;
		
	
		\eIf{$depth$}
		{
			$\best[\anode] = \min(|\posex(\anode=\test[\anode])|,|\negex(\anode=\test[\anode])|)$\;
			$\opt[\anode] = \tru$\;
			\ForEach{$branch \in \{\tru, \fal\}$}
			{
				% $\child[\anode,branch] \gets (|\posex(\anode=\test[\anode])| > |\negex(\anode=\test[\anode])|)$\;
				\lIf{$|\posex(\anode=\test[\anode])| > |\negex(\anode=\test[\anode])|$}{$\child[\anode,branch] \gets \top$}
				\lElse{$\child[\anode,branch] \gets \bot$}
			}
		}
		{
			$\blossom \gets \blossom \cup \{n\}$\;
			$\best[\anode] = \min(|\posex(\anode)|, |\negex(\anode)|)$\;
			$\opt[\anode] \gets \fal$\;
		}


	\end{algorithm}


	\begin{algorithm}
		\caption{Suppress a node and all its descendants\label{alg:free}}
		\TitleOfAlgo{\prune}
	  \KwData{integer \anode}

		$\blossom \gets \blossom \setminus \{\anode\}$\;
		$\nodes \gets \nodes \setminus \{\anode\}$\;

		\ForEach{$branch \in \{\tru, \fal\}$}
		{
		\lIf{$\child[\anode,branch] \not\in \{\top, \bot\}$}
		{
			$\prune{\child[\anode,branch]}$
		}
		}

		\lIf{$\depth[\anode] = k-1$ or $\opt[\anode]$}{$error \gets error - \best[\anode]$}

	\end{algorithm}


\begin{algorithm}
	\caption{Search loop\label{alg:search}}
  \TitleOfAlgo{\dt}
  \KwData{$\negex,\posex, k$}
  \KwResult{A decision tree}

	$\bnode \gets 0$\;
	$\posex(1),\negex(1) \gets \posex, \negex$\;
	$\grow{\blossom, \sequence, 1}$\;

	\While{\textbf{true}}{
		\eIf{$\blossom = \emptyset$} {
			$\ub \gets \min(\ub,\error)$\;
			$deadend \gets \fal$\;
			\Repeat{$deadend$}{
				\lIf{$\bnode > 0$}{$\opt[\bnode] \gets \tru$}
				\lIf{$\bnode = 1$}{\Return}
				$\bnode \gets \pop{\sequence}$\;
				$\best[\bnode] \gets \min(\best[\bnode], \best(\child[\bnode,\tru]) + \best(\child[\bnode,\fal]))$\;
				$\test[\bnode] \gets \pop{\dom[\bnode]}$\;
				$\prune(\child[\bnode,\tru])$\;
				$\prune(\child[\bnode,\fal])$\;

				$deadend \gets \best[\bnode] = 0 ~\vee~ \dom[\bnode] = \emptyset$\;
				\If{$deadend$}
				{
				$\opt[\bnode] \gets \tru$\;
				$\error \gets \error + \best[\bnode]$\;
				}
			}
			$\blossom \gets \blossom \cup \{b\}$\;
			$\error \gets \error + \min(|\posex(\bnode)|, |\negex(\bnode)|)$\;
		}
		{
			\If{$b = 0$}{
				$b=\select{\blossom}$\;
				% $\blossom \gets \blossom \setminus \{b\}$\;
				$\push(\bnode,\sequence)$\;
			}
			$c_{\tru}, c_{\fal} = \argmin_{x,y}(\mathbb{N} \setminus \nodes)$\;
			$\posex(c_{\tru}),\negex(c_{\tru}),\posex(c_{\fal}),\negex(c_{\fal}) \gets \branch(\posex(\bnode),\negex(\bnode),\test[\bnode])$\;
			\ForEach{$branch \in \{\tru, \fal\}$}{
				\eIf{$\min(|\posex(c_{branch})|,|\negex(c_{branch})|) = 0$}
				{
					\lIf{$|\posex(c_{branch})|>|\negex(c_{branch})|$}{$\child[\bnode,branch] \gets \top$}
					\lElse{$\child[\bnode,branch] \gets \bot$}
				}{
					$\child[\bnode,branch] \gets c_{branch}$\;
					$\depth[c_{branch}] \gets \depth[\bnode]+1$\;
					$\grow(\blossom, \sequence, c_{branch})$\;
				}
			}
			$\bnode \gets 0$\;
		}
	}

\end{algorithm}

\section*{Experiments}


\begin{table}[htbp]
\begin{center}
\begin{footnotesize}
\tabcolsep=5pt
\input{src/tables/thetable.tex}
\end{footnotesize}
\end{center}
\caption{\label{tab:thetable} Some results (max depth=4)}
\end{table}

\clearpage

\begin{table}[htbp]
\begin{center}
\begin{footnotesize}
\tabcolsep=5pt
\input{src/tables/depth5.tex}
\end{footnotesize}
\end{center}
\caption{\label{tab:thetable} Restarts (max depth=5)}
\end{table}

% \begin{table}[htbp]
% \begin{center}
% \begin{footnotesize}
% \tabcolsep=5pt
% \input{src/tables/depth5b.tex}
% \end{footnotesize}
% \end{center}
% \caption{\label{tab:thetable} Restarts (max depth=5)}
% \end{table}

\clearpage

\begin{table}[htbp]
\begin{center}
\begin{footnotesize}
\tabcolsep=5pt
\input{src/tables/depth8.tex}
\end{footnotesize}
\end{center}
\caption{\label{tab:thetable} Restarts (max depth=8)}
\end{table}

\begin{table}[htbp]
\begin{center}
\begin{footnotesize}
\tabcolsep=5pt
\input{src/tables/depth10.tex}
\end{footnotesize}
\end{center}
\caption{\label{tab:thetable} Restarts (max depth=10)}
\end{table}



\end{document}

